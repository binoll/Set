SET (МНОЖЕСТВО)
=========================

Описание:
-------------------------

**Множество** — это структура данных, содержащая конечный набор элементов некоторого типа. 
Каждый элемент содержится только в одном экземпляре, т.е. разные элементы множества 
не равны между собой. Элементы множества никак не упорядочены. 
В множество M можно добавить элемент x, из множества M можно удалить элемент x. 
Если при добавлении элемента x он уже содержится в множестве M, то ничего не 
происходит. Аналогично, никакие действия не совершаются при удалении элемента x, 
когда он не содержится в множестве M. Для заданного элемента x можно определить, 
содержится ли он в множестве M. Множество может содержать любое конечное число элементов.

**Характеристическим вектором** (вектором индикатором) VA множества A, 
заданного на универсальном множестве U (U - множество, состоящее из всех элементов 
типа, к которому относятся элементы рассматриваемого множества А), является вектор, 
содержащий 0 и 1. Количество элементов в векторе VA равно количеству элементов в 
универсальном множестве, причём, 1 записывается в случае, если элемент присутствует 
и в универсальном множестве U, и в множестве A, в противном случае записывается 0.

Реализация:
-------------------------
**1. В виде массива элементов:**

Рассмотрим реализацию обычного множества, элементы которого хранятся 
в массиве размером N (максимально возможная мощность множества), 
начиная с первой ячейки. Специальная переменная (например, size) 
содержит текущее число элементов множества (текущую мощность множества), 
т.е. количество используемых в данный момент ячеек массива.

![1.png](img%2F1.png)

При добавлении элемента x к множеству сначала необходимо определить, 
содержится ли он в множестве (если содержится, то множество не меняется). 
Для этого используется функция поиска элемента, которая проверяет, 
принадлежит ли элемент x множеству, и, если принадлежит, возвращает индекс 
ячейки массива, содержащей x. Та же функция поиска используется и при удалении 
элемента из множества. При добавлении элемента он дописывается в конец (в ячейку 
массива с индексом size) и переменная size увеличивается на единицу. 
Для удаления элемента достаточно последний элемент множества переписать 
на место удаляемого и уменьшить переменную size на единицу. 
В данной реализации элементы множества хранятся в массиве в произвольном порядке. 
Это означает, что при поиске элемента x придётся последовательно перебрать все элементы, 
пока мы либо не найдем x, либо не убедимся, что его там нет. Поэтому эта реализация 
годится только для множеств небольшой мощности. Главным достоинством данной реализации 
является отсутствие ограничения на тип элементов, хранимых в массиве (элементами могут 
быть как простые типы данных, строки и вещественные числа, так и структуры данных, 
которые представляют более сложную реализацию). Также стоит отметить высокую скорость доступа к k-му элементу, 
где k – индекс элемента в массиве. 
Из недостатков необходимо отметить низкую скорость поиска элемента, 
так как приходится в худшем случае перебирать все элементы множества. 
Также недостатком является ограничение количества элементов, которое задаётся 
при инициализации массива. Возможны операции изменения размерности массива, 
но они несут опреде¬лённые затраты ресурсов и могут существенно снизить эффективность 
работы с множеством.

**2. Битовая реализация характеристического вектора:**

Для реализации множеств из целых чисел, принадлежащих отрезку, используется 
битовая реализация множества на базе массива элементов типа char. 
Пусть имеется множество M из целых чисел, принадлежащих отрезку [l, r], где l и r – 
целые числа (l≤r). Отведем для этого множества несколько соседних байтов памяти и 
поставим в соответствие каждому числу из отрезка [l, r] один бит одного из этих байтов 
по следующему правилу: числу l – самый правый бит самого первого байта, числу l+1 – 
следующий бит этого байта и так бит за битом сначала в первом байте, затем в следующем 
байте и т.д. Байты заполняются следующим образом: если число принадлежит множеству, то 
в соответствующий ему бит записываем 1, если не принадлежит, то записываем 0. 
Число байтов, которые необходимо отвести под множество равно (r-l) / 8 + 1 
(целочисленное деление) Пусть k - число из отрезка [l, r]. Если вести отсчет 
от начального байта, выделенного для множества, и считать его нулевым, и если биты 
в каждом байте нумеровать справа налево, начиная с 0, тогда байт, в котором находится 
бит, отвечающий за число k вычисляется по формуле:*Номер байта = (k – l) / 8* 
(целочисленное деление), а номер бита, соответствующего числу k, вычисляется по 
формуле *Номер бита= (k – l) % 8* (остаток от деления).

Задание:
-------------------------
Реализовать на языке С++ два класса:  
1. SetChar – множество символов (коды ASCII). 
2. SetInt – множество целых чисел, принадлежащих диапазону [l, r].
3. Создать тесты для 
проверки корректности реализации классов 
с операциями. 
4. Произвести сравнительную оценку 
времени выполнения операций включения и исключения 
(всех элементов) для разработанных классов и аналогичных операций с использованием классов STL (set и unordered_set).  
   
Использовать битовую реализацию характеристического вектора на базе массива, элементы которого
имеют тип char.